<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- People who read source code are awesome.
         Here you are: https://github.com/filiph/filiphnet -->

    <meta charset="utf-8">
    <title>Chapter 2: Performance, speed, efficiency</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="alternate" type="application/atom+xml" title="Filip Hracek’s Flutter Performance Book" href="https://filiph.net/flutter-performance/atom.xml" />

    <meta property="og:title" content="Chapter 2: Performance, speed, efficiency">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://filiph.net/flutter-performance/020-performance-speed-efficiency.html">
    <meta property="og:description" content="What's the difference?">
    <meta property="og:image" content="https://filiph.net/img/filiphnet-text.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@filiphracek">
    <meta name="twitter:title" content="Chapter 2: Performance, speed, efficiency">
    <meta name="twitter:description" content="What's the difference?">
    <meta name="twitter:image" content="https://filiph.net/img/filiphnet-text.png">

    <meta name="robots" content="all" />
    <meta name="description" content="What's the difference?" />
    <meta name="author" content="Filip Hracek" />

    <style>
      .wrapper {
        max-width: 600px;
        margin: 0 auto;
        padding: 5vw;
      }

      body {
        font-family: Georgia, serif;
      }

      h1, h2 {
        font-family: "Helvetica Neue", Helvetica, sans-serif;
        font-weight: 300;
        text-wrap: balance;
      }

      .above-title {
        font-family: "Helvetica Neue", Helvetica, sans-serif;
        font-size: 0.9rem;
        text-transform: uppercase;
        text-wrap: balance;
      }

      h1 {
        margin-top: 0;
        font-size: 2.6rem;
      }

      h2 {
        font-size: 1.8rem;
        margin-top: 1.6em;
      }

      ul {
        padding-left: 2em;
      }

      p, li {
        font-size: 1.2rem;
        line-height: 1.5em;
      }

      li {
        /*list-style: none;*/
      }

      a, abbr {
        text-decoration: none;
      }

      img, video {
        display: block;
        margin-left: auto;
        margin-right: auto;
        max-width: 100%;
      }

      .signature {
        text-align: right;
      }

      .footer {
        margin-top: 3em;
        border-top: 5px solid gray;
      }

      .filip-portrait {
        margin-top: 1em;
        margin-right: 2em;
        margin-bottom: 1em;
        width: 175px;
        float: left;

        animation: appear-portrait 6s;
      }

      @keyframes appear-portrait { 0% {opacity: 0;} 40% {opacity: 1;} }

      .note {
        text-transform: uppercase;
        font-size: 60%;
        font-family: "Helvetica Neue", Helvetica, sans-serif;
      }

      .highlight {
        background-color: yellow;
      }

      @media screen and (max-width: 380px) {
        .portrait {
          float: none;
          display: block;
          margin: 0 auto;
        }
      }
    </style>

    <script>
      // Docs here: https://docs.mathjax.org/en/latest/options/input/tex.html
      MathJax = {
        tex: {
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <div class="wrapper">

      <p class="above-title">
        <a href="/">Filip Hráček</a> /
        <a href="/flutter-performance">Flutter performance</a> /
      </p>

      <h1>Chapter 2: Performance, speed, efficiency</h1>

      <p>I’m intentionally calling this book “Flutter Performance” even though the term is vague. That’s because, if you care about optimizing apps or games, you’re not looking at one neat metric. You have to have a more complex view.</p>
<p>That said, we can build such a view from smaller parts.</p>
<h2 id="efficiency">Efficiency</h2>
<p>Efficiency is the easiest term to define and measure. Given a problem, the more efficient program simply <em>does less work</em>.</p>
<p>Let’s say you want to find the highest number in a list of numbers. That’s the problem. In practical terms, efficiency is how many CPU instructions you need to execute to get the highest number. The fewer instructions you execute, the more efficient your program.</p>
<p>Here’s an example of ARM64 assembly code for finding a maximum value in an array:</p>
<pre><code class="language-asm">findMax:
        sub     sp, sp, #48    # Allocate 48 bytes on stack
        str     x0, [sp, 8]    # Store array pointer at sp+8
        str     w1, [sp, 4]    # Store array length at sp+4
        str     xzr, [sp, 32]  # Initialize max value to 0
        str     wzr, [sp, 44]  # Initialize loop counter (i) to 0
        b       .L2            # Branch to loop condition

.L5:    # Main loop body
        ldrsw   x0, [sp, 44]   # Load loop counter (sign-extended)
        lsl     x0, x0, 3      # Multiply by 8 (size of double)
        ldr     x1, [sp, 8]    # Load array pointer
        add     x0, x1, x0     # Calculate address of current element
        ldr     d31, [x0]      # Load current element into d31
        str     d31, [sp, 24]  # Store current element on stack
        ldr     d30, [sp, 24]  # Load current element into d30
        ldr     d31, [sp, 32]  # Load current max into d31
        fcmpe   d30, d31       # Compare current with max
        bgt     .L7            # If current &gt; max, branch to L7
        b       .L3            # Else continue to L3

.L7:    # Update maximum value
        ldr     d31, [sp, 24]  # Load current value
        str     d31, [sp, 32]  # Store as new maximum

.L3:    # Increment counter
        ldr     w0, [sp, 44]   # Load counter
        add     w0, w0, 1      # Increment by 1
        str     w0, [sp, 44]   # Store updated counter

.L2:    # Loop condition
        ldr     w1, [sp, 44]   # Load counter
        ldr     w0, [sp, 4]    # Load array length
        cmp     w1, w0         # Compare counter with length
        blt     .L5            # If counter &lt; length, continue loop
        ldr     d31, [sp, 32]  # Load final maximum value
        fmov    d0, d31        # Move to return register d0
        add     sp, sp, 48     # Deallocate stack space
        ret                    # Return
</code></pre>
<p>And here’s the same program, but compiled in a higher optimization level. The listing above was compiled with the <code>-O0</code> flag (default mode). The listing below was compiled with the <code>-O3</code> flag (a lot more optimizations enabled).</p>
<pre><code class="language-asm">findMax:
        movi    d0, #0              # Initialize max (d0) to 0
        cmp     w1, 0               # Compare array length with 0
        ble     .L1                 # If length &lt;= 0, return
        add     x1, x0, w1, uxtw 3  # Calculate end address

.L3:    # Loop body
        ldr     d31, [x0], 8        # Load double and increment x0 by 8
                                    # Post-indexed addressing mode
        fcmpe   d31, d0             # Compare current value with max
        fcsel   d0, d31, d0, gt     # Select larger value (d31 if d31 &gt; d0)
        cmp     x1, x0              # Compare current pointer with end address
        bne     .L3                 # Continue if not at end

.L1:
        ret                         # Return max value in d0
</code></pre>
<p>Even if you've never seen assembly, you can probably tell that the second listing does less work. There are simply fewer instructions. The unoptimized version does a lot of loading (<code>ldr</code>) and storing (<code>str</code>) into memory, and lacks the obvious optimization of skipping the whole function if the list is empty (<code>cmp w1, 0</code> — is the length zero? <code>ble .L1</code> — if so, jump to the end of the function).</p>
<p>More efficient code does less work, and therefore draws less energy and improves battery life.</p>
<p>It also generally finishes faster. But not always.</p>
<h2 id="speed">Speed</h2>
<p>A program can do less work but still be slower.</p>
<p>One obvious way this happens is when using parallelism. A Dart program can spawn a separate isolate and outsource half of its work to it. By doing so, it will be finished almost twice as fast, but it will also do slightly more work (for example, the work to spawn the extra isolate). Slightly lower efficiency, more complex code, but also much faster execution.</p>
<p>Another reason why efficiency and speed sometime don’t go hand in hand is the fact that not all CPU operations take the same amount of time. A CPU loads a number from memory address <code>x0</code> to register <code>d31</code>. (That’s <code>ldr d31, [x0]</code> in ARM assembly.) This operation can take something like 1 nanosecond if the address <code>x0</code> happens to be in Level 1 (L1) cache that sits right next to the CPU. But the same load instruction will take 70-100 nanoseconds if <code>x0</code> is currently not in one of the L1-L3 caches and must be obtained from RAM. (This is why data locality  matters and why we’ll be coming back to this.) So, once again, you can do fewer instructions and therefore have higher efficiency but still be slower.</p>
<p></p>
<img src="Screenshot 2025-01-13 at 15.27.53.png">
<p>Now, this is where we might stop if we were building mainframe programs. In the old days — like, way before my time even — the most important programs were batch jobs. Think about something like cracking a military code, where you feed a program with the encoded message and some parameters, and you let it run for minutes or even hours. Same with weather forecast or a ballistic research computer, which runs a physics simulation for a long time before spitting out a result.</p>
<p>These programs needed efficiency and speed, of course, especially since hardware was so slow and expensive back then. What they didn't need was nice user experience.</p>
<p>If you were running a weather forecast simulation in the 1960s, you didn't care how usable or unusable the computer got while it was processing — because the simulation was probably the only program running. You just patiently waited.</p>
<p>Today, though, most computing is different. You expect your pocket computer to update a multi-megapixel screen at least 60 times per second while it’s also decoding an animated gif meme in the background. Most computation comes in very short bursts between frames, not in multi-minute batches.</p>
<p>This is why we also need to talk about jank.</p>
<h2 id="jank">Jank</h2>
<p>In computing, “jank” is a word for a perceptible pause in the smooth rendering of an app’s user interface.<sup class="footnote-ref"><a href="#fn-jank_videogames" id="fnref-jank_videogames">1</a></sup> If your app renders at 60 frames per second, and then suddenly freezes for a moment, that’s jank.</p>
<p>Technically speaking, jank isn’t a “bug”, in the traditional sense. The app still works — it just isn’t rendering as smoothly as we’d like it to. But jank <em>can</em> lead to user error, and it definitely leads to frustration and the perception of low quality.</p>
<p>Our tools and our thinking sometimes haven’t caught up to this new reality — but jank is a real problem and we’ll spend a significant part of the book learning how to avoid it. We’re not in the mainframe days anymore.</p>
<h2 id="perception">Perception</h2>
<p>Jank is when the app objectively, measurably freezes. But there exists a subtler, less concrete, more “fluffy” kind of performance problem — the <em>user perception</em> of sluggish performance.</p>
<p>I dedicate a whole chapter to this idea but for now, let’s just say that it’s absolutely possible to have a fast, efficient, jank-free app that nevertheless feels sluggish. And it’s also possible to have an app with occasional, well-placed jank that feels snappy and smooth.</p>
<p>Perception, in this case, is <em>everything.</em></p>
<h2 id="memory-consumption">Memory consumption</h2>
<p>Performance optimization is all about tradeoffs, and one of the more important tradeoffs is the one between “time and space”. That is to say, speed and memory. This is because, in many cases, you can trade one for the other.</p>
<p>To give an example, you can make your $\ln(x)$ (natural logarithm) computation faster by precomputing a table of results in a $x\rightarrow\ln(x)$ map. That approach will let you avoid some CPU cycles — but the table will also consume some space in memory. (You obviously need to be smart about the range and granularity of the precomputed table because — from what I understand — computers with infinite amounts of RAM are in short supply.)</p>
<p>The opposite silly example would be to never cache anything, and always recompute all secondary data from first principles. That would save on memory but it would also make everything extremely slow. Imagine Flutter having to downsize images every frame anew, for example, instead of caching the result.</p>
<p>But memory’s role in performance is more complex than just the time-space tradeoff. When a device runs low on memory, the operating system needs to deal with it, shutting down apps on the background or moving parts of RAM to disk (memory swapping). This makes things slower. Moreover, memory for short-living objects needs to be allocated and then later freed (garbage collected), which is also additional work that can lead to jank.</p>
<p>In extreme cases, too much memory consumption can lead to your app being outright shut down. For example, the Chrome browser has a certain limit to what a single tab can allocate. When the limit is reached, Chrome will simply crash the tab.</p>
<img src="Screenshot 2025-03-06 at 14.20.51.png" loading="lazy">
<p>So memory is an integral part of performance and it interacts with it in complex ways. We’ll talk about all that in a later chapter.</p>
<h2 id="performance">Performance</h2>
<p>Now we can finally get to “performance.” Hopefully, by now you understand that performance is not an easily defined term. It has elements of efficiency in it (which is nicely measurable) but it also encompasses fluffier ideas, such as “acceptable jank” and perception. Performance can be — and often is — in the eye of the beholder.</p>
<p></p>
<p>Some authors have a problem with this. They want an exact definition before they delve deeper. I understand this and, to be honest, only a few short years ago I was one of those people. But these days, I would much rather focus on practical matters than to try to pinpoint an exact definition.</p>
<p>The field of performance optimization is full of exact measurements and precise methodology. Yet the <em>idea</em> of app performance is — in my view — <em>impossible</em> to collapse into well-defined metrics.</p>
<p>There’s a name for our tendency to discount anything that cannot be quantified: <em>McNamara fallacy</em>, named after the US Secretary of Defense during the Vietnam war. The story<sup class="footnote-ref"><a href="#fn-mcnamara" id="fnref-mcnamara">2</a></sup> goes that McNamara was trying to come up with a list of aspects to follow the progress of the war. An Air Force general suggested that one such aspect could be the feelings of the Vietnamese people.</p>
<p>McNamara wrote this down, then immediately erased it. “How can anyone get a reading on people’s feelings?” he asked sarcastically. Feelings cannot be measured, and therefore they must not be important.</p>
<p></p>
<p>McNamara’s example might be a bit extreme, but there’s a related phenomenon that you can observe almost everywhere — <em>surrogation</em>. It’s when people begin to believe that a metric <em>is</em> what it attempts to measure:</p>
<ul>
<li>Customer satisfaction survey score <em>is</em> customer satisfaction.</li>
<li>Patient wait times <em>are</em> hospital efficiency.</li>
<li>Net promoter score <em>is</em> word of mouth.</li>
<li>Graduation rates <em>are</em> school effectiveness. </li>
<li>View count <em>is</em> video quality.</li>
<li>...</li>
<li>Lines of code <em>is</em> developer productivity.</li>
<li>Number of comments <em>is</em> code documentation quality.</li>
<li>Function length <em>is</em> code complexity.</li>
<li>Test coverage percentage <em>is</em> code quality.</li>
<li>Benchmark results <em>are</em> performance.</li>
</ul>
<p>None of these are true, as I hope everyone realizes.</p>
<p>As unsatisfying as it might feel, I’ll keep the term “performance” vaguely defined by the combination of efficiency, speed, lack of jank, and subjective perception of responsiveness.</p>
<section class="footnotes">
<ol>
<li id="fn-jank_videogames">
<p>Don’t confuse with the meaning of “jank” in videogames, where it’s about game mechanics that break immersion or disrupt play. <a href="#fnref-jank_videogames" class="footnote-backref">↩</a></p>
</li>
<li id="fn-mcnamara">
<p>Rufus Phillips: <em>Why Vietnam Matters: An Eyewitness Account of Lessons Not Learned</em> (2017), pp. xiii-xiv. <a href="#fnref-mcnamara" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>


      <p class="signature">
        <a href="/flutter-performance/#chapters">(back to index)</a>
      </p>

      <div class="footer">
        <img class="filip-portrait" width="175" height="233" src="/img/filip.jpg" srcset="/img/filip.jpg 1x, /img/filip@2x.jpg 2x, /img/filip@3x.jpg 3x, /img/filip@4x.jpg 4x" alt="Filip Hracek’s face">
<p><a href="https://filiph.net/">Filip</a> worked at Google for 14 years — the last 6 on the Dart and Flutter teams in Mountain View. You may recognize him from some of the educational content from that time. Now he’s based in Prague as an open-source contractor and game developer. He writes Dart code every day.</p>
<p>The text you just read is supposed to be a chapter in Filip’s planned <a href="/flutter-performance/">book about Dart and Flutter performance</a>.
<a href="/await">Get notified</a> when he’s finished.</p>
<!--
His main project these days is
[GIANT ROBOT GAME](https://store.steampowered.com/app/2538440/GIANT_ROBOT_GAME/)
(Steam link).
-->


        <p><small><a href="https://filiph.net/flutter-performance/atom.xml">RSS</a></small></p>
      </div>
    </div>
  </body>
</html>
