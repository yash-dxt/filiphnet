<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- People who read source code are awesome.
         Here you are: https://github.com/filiph/filiphnet -->

    <meta charset="utf-8">
    <title>Chapter 5: Performance lottery</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <link rel="alternate" type="application/atom+xml" title="Filip Hracek’s Flutter Performance Book" href="https://filiph.net/flutter-performance/atom.xml" />

    <meta property="og:title" content="Chapter 5: Performance lottery">
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://filiph.net/flutter-performance/050-performance-lottery.html">
    <meta property="og:description" content="The unpredictability of app performance.">
    <meta property="og:image" content="https://filiph.net/img/filiphnet-text.png">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@filiphracek">
    <meta name="twitter:title" content="Chapter 5: Performance lottery">
    <meta name="twitter:description" content="The unpredictability of app performance.">
    <meta name="twitter:image" content="https://filiph.net/img/filiphnet-text.png">

    <meta name="robots" content="all" />
    <meta name="description" content="The unpredictability of app performance." />
    <meta name="author" content="Filip Hracek" />

    <style>
      .wrapper {
        max-width: 600px;
        margin: 0 auto;
        padding: 5vw;
      }

      body {
        font-family: Georgia, serif;
      }

      h1, h2 {
        font-family: "Helvetica Neue", Helvetica, sans-serif;
        font-weight: 300;
        text-wrap: balance;
      }

      .above-title {
        font-family: "Helvetica Neue", Helvetica, sans-serif;
        font-size: 0.9rem;
        text-transform: uppercase;
        text-wrap: balance;
      }

      h1 {
        margin-top: 0;
        font-size: 2.6rem;
      }

      h2 {
        font-size: 1.8rem;
        margin-top: 1.6em;
      }

      ul {
        padding-left: 2em;
      }

      p, li {
        font-size: 1.2rem;
        line-height: 1.5em;
      }

      li {
        /*list-style: none;*/
      }

      a, abbr {
        text-decoration: none;
      }

      img, video {
        display: block;
        margin-left: auto;
        margin-right: auto;
        max-width: 100%;
      }

      .signature {
        text-align: right;
      }

      .footer {
        margin-top: 3em;
        border-top: 5px solid gray;
      }

      .filip-portrait {
        margin-top: 1em;
        margin-right: 2em;
        margin-bottom: 1em;
        width: 175px;
        float: left;

        animation: appear-portrait 6s;
      }

      @keyframes appear-portrait { 0% {opacity: 0;} 40% {opacity: 1;} }

      .note {
        text-transform: uppercase;
        font-size: 60%;
        font-family: "Helvetica Neue", Helvetica, sans-serif;
      }

      .highlight {
        background-color: yellow;
      }

      @media screen and (max-width: 380px) {
        .portrait {
          float: none;
          display: block;
          margin: 0 auto;
        }
      }
    </style>

    <script>
      // Docs here: https://docs.mathjax.org/en/latest/options/input/tex.html
      MathJax = {
        tex: {
          inlineMath: [['$', '$']],
          displayMath: [['$$', '$$']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  </head>
  <body>
    <div class="wrapper">

      <p class="above-title">
        <a href="/">Filip Hráček</a> /
        <a href="/flutter-performance">Flutter performance</a> /
      </p>

      <h1>Chapter 5: Performance lottery</h1>

      <p>Let me tell you a true story. In early 2019, we were building a demo game for that year’s Google I/O developer conference. In terms of programming, it was mostly Luigi Rosso (of Rive fame) and me, and at one point I decided to have a look at the game’s performance. Not that we saw any major issues: I just wanted to make sure that I’m not unwittingly releasing a piece of “evidence” that “Flutter is slow”.</p>
<p></p>
<p>I wrote a benchmark and ran it on my testing Android device. I saw some high frame build times, so I made an obvious performance optimization, and ran the benchmark again.</p>
<p>To my surprise, the optimization made the app <em>slower</em>. Build times were longer and framerate was lower. A complete disaster.</p>
<p>I though I was going crazy (a common symptom of dealing with performance lottery, by the way). I was inexperienced, so I worked under the assumption that my optimization <em>must</em> be flawed somehow. Unfortunately, I don’t remember what that optimization was, exactly, but you’ll have to trust me it was something really obvious.</p>
<p>Anyway, I sunk several hours into this. At some point, I was so frustrated that I put a <code>print()</code> statement into a function in order to confirm that the function is actually being called every frame.  The print statement worked, and I saw a bunch of output in the console scroll by. (Back then, Android <code>logcat</code>'s “Fold similar content” feature didn't exist yet, so duplicate log messages weren't collapsed into a single one. I really <em>did</em> see the messages scroll by, at a rate of about 60 lines per second.)</p>
<p>And then I noticed that this change, <em>the addition of a completely useless <code>print()</code> statement,</em> made build times significantly <em>shorter</em>. There was suddenly no jank.</p>
<img src="ab9ce9447edbe163a066d0eff0318459.jpg">
<p>WAT?</p>
<p>Now, listen. Even this bizarre incident has a perfectly reasonable explanation. Of course that adding a print statement doesn’t actually improve performance. But, before I get to the explanation, I want to emphasize how completely random this seemed to be at the time. I want to marinate you a bit longer in this state of confusion so that you deeply understand the true meaning of “performance lottery.” A <em>single line</em> that should have had a <em>detrimental</em> effect to performance, if any, actually <em>improved</em> performance in <em>all</em> the ways I measured. Imagine yourself looking at this kind of result, and being able to reproduce it again and again.</p>
<p>Madness. Absolute madness.</p>
<p>Ok, now I think you’re ready for the explanation <em>for this particular instance of performance lottery.</em> Turns out that modern mobile operating systems have something called a governor. This is a power management component that adjusts CPU clock speed (i.e. frequency) according to some predetermined rules.</p>
<p>So if the governor believes that the smartphone is more or less idle, it will lower the processor frequency. Then, when you touch the screen, for example, the governor will immediately set the CPU clock speed to maximum. (This happens instantaneously, so the user has no idea their phone just got significantly faster. There’s no perceptible “warm-up” period.)</p>
<p>The idea of governors is fantastic for us as everyday users. Governors let us use our hardware to its fullest when needed, but they also save battery and decrease device heat.</p>
<p>The same idea, unfortunately, is also absolute poison for as as performance engineers.</p>
<p>You may have already guessed what happened with my unexpected <code>print()</code> speedup. Before I added the print statement, the governor evaluated the game as something that doesn’t really need high performance. It was doing just fine on a lower clock speed, so why waste battery?</p>
<p>Then, I introduced the <code>print()</code> statement. I know that a single print statement doesn’t look like much but remember that, on an Android device (at least at that time), each of those print calls meant that:</p>
<ol>
<li>Dart needed to allocate memory for the new <code>String</code> (it was not a constant literal but something dynamic, such as <code>“iteration $i”</code>)</li>
<li>Dart needed to send the <code>String</code> to the Android OS logging subsystem</li>
<li>Android OS had to receive the String and put it into its log ring buffer (<code>logcat</code>)</li>
<li>Android OS then had to <em>send</em> the log message via USB Debugging connection to my workstation (which was running the performance test in profile mode)</li>
</ol>
<p>That’s not a <em>lot</em> of work, but it was enough to push the game — in the eyes of the governor — to the “needs more CPU clock speed” category. Rather than letting the app jank, the governor decided to switch the device to high-performance mode. Again, this is a good choice from the user’s perspective.</p>
<p>But it’s also why a less efficient, more wasteful game was running significantly faster. Performance was improved by <em>adding completely unnecessary work.</em></p>
<p>Now, once I found out about governors, I sighed a deep sigh of relief (“I’m not going crazy yet”) and started working on eliminating the influence of governors on performance testing. You can read more on that in the <em>Hardware</em> chapter.</p>
<p></p>
<p>Here, I’d like to return to the topic at hand: performance lottery. It’s when you make a change to your code, and the observed performance effect is seemingly disconnected from that change.</p>
<p>Here are a few additional examples:</p>
<ul>
<li>You refactor a method and, by doing so, make it a few operations shorter. Suddenly, the shorter method fits into some compiler heuristic, and the compiler now optimizes it much better. This leads to faster code although your original change wasn’t a performance optimization at all.</li>
<li>You come up with a performance optimization for a tight loop. The effect of <em>your</em> change is only 1% speedup but, incidentally, you also made an array in your code a tiny bit smaller (maybe from 17 elements to 16) and now things fit into the CPU’s L1 cache. When you run your benchmark, you get an amazing 20% speedup, and you start to think of yourself as a performance guru. (Until you try that same optimization elsewhere — with big fanfare — and only see the meager 1% speedup because you don’t win the performance lottery that time. So now you think of yourself as a performance clown.)</li>
<li>You notice that a microbenchmark consistently runs slower on your colleague’s workstation, even though the two machines are identical. After a long and arduous investigation, you realize that the culprit is <em>the username</em>. Your colleague’s username is longer than yours. That means she runs the benchmark from a directory with a longer overall length (e.g. <code>/home/mylongusername/...</code>). The current working directory is in your environment variables, which are in memory, and so a different username length moves the program stack. This leads to a different memory layout, which can lead to a cache set conflict, which can have a significant impact on performance.<sup class="footnote-ref"><a href="#fn-mytkowicz" id="fnref-mytkowicz">1</a></sup> </li>
<li>You follow the common wisdom that inlining functions makes code run faster because it avoids the overhead of a function call (if you don’t know what inlining is yet, don’t worry, we’ll get to that). So you inline as much of your code as possible. Unfortunately, you’re building for a system with an infamously low memory throughput — so your inlining actually makes everything <em>slower</em> without you realizing it. This is because the inlining makes the compiled machine code larger, and the device spends more time accessing it, which more than offsets any advantage of inlining. This one happened to Nintendo with their Super Mario 64 game on N64. When a modder named Kaze Emanuar “un-optimized” the game in 2024 (28 years after release!), he got significantly better performance. </li>
</ul>
<p>It’s important to understand that, despite the name, performance lottery <em>isn’t</em> random chance. The processor doesn’t throw dice to decide whether it will work fast or slow today. Every instance of performance lottery can be explained by some deterministic cause. Sometimes you find the cause, sometimes you don’t — but it’s always there.</p>
<p>In practice, though, it <em>is</em> a lottery. Modern computing is so incredibly complicated and layered that any code change can have unintended knock on effects. Somewhere in the black box that is hardware architecture (branch prediction, pipelining, CPU cache hierarchy, ...) and software environment (governors, memory layout, compiler heuristics), something lurks that will make your code run either faster or slower. Sometimes, you’ll figure it out. But often, you simply won’t know why it happened, or even <em>that</em> it happened.</p>
<p>Unless you want to spend the rest of your life trying to understand the entirety of the modern software and hardware stack, you better make peace with the fact that performance lottery is real.</p>
<section class="footnotes">
<ol>
<li id="fn-mytkowicz">
<p>I won’t go into details of this one since it’s so low-level and mostly relevant to C and C++ programmers. But if you’re interested, I encourage you to watch Emery Berger’s Strange Loop talk “Performance Matters” or read the paper by Mytkowicz et al. titled “Producing Wrong Data Without Doing Anything Obviously Wrong!” from 2009. <a href="#fnref-mytkowicz" class="footnote-backref">↩</a></p>
</li>
</ol>
</section>


      <p class="signature">
        <a href="/flutter-performance/#chapters">(back to index)</a>
      </p>

      <div class="footer">
        <img class="filip-portrait" width="175" height="233" src="/img/filip.jpg" srcset="/img/filip.jpg 1x, /img/filip@2x.jpg 2x, /img/filip@3x.jpg 3x, /img/filip@4x.jpg 4x" alt="Filip Hracek’s face">
<p><a href="https://filiph.net/">Filip</a> worked at Google for 14 years — the last 6 on the Dart and Flutter teams in Mountain View. You may recognize him from some of the educational content from that time. Now he’s based in Prague as an open-source contractor and game developer. He writes Dart code every day.</p>
<p>The text you just read is supposed to be a chapter in Filip’s planned <a href="/flutter-performance/">book about Dart and Flutter performance</a>.
<a href="/await">Get notified</a> when he’s finished.</p>
<!--
His main project these days is
[GIANT ROBOT GAME](https://store.steampowered.com/app/2538440/GIANT_ROBOT_GAME/)
(Steam link).
-->


        <p><small><a href="https://filiph.net/flutter-performance/atom.xml">RSS</a></small></p>
      </div>
    </div>
  </body>
</html>
